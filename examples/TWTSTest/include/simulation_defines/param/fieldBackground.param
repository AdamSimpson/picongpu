/**
 * Copyright 2014 Alexander Debus, Axel Huebl
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once
#include "plugins/radiation/complex.hpp"
#include "fields/numericalCellTypes/YeeCell.hpp"
#include "math/Vector.hpp"
#include <iostream>

namespace picongpu
{
    namespace fieldBackground
    {
		/* Add this additional field for pushing particles */
		const bool includeTWTSlaser = true;
		const bool includeCollidingTWTS = false;
		
        namespace SI
        {
            /** unit: meter */
            const double WAVE_LENGTH_SI = 0.8e-6;

            /** UNITCONV */
            const double UNITCONV_Intens_to_A0 = ::picongpu::SI::ELECTRON_CHARGE_SI * ::picongpu::SI::ELECTRON_CHARGE_SI * 2.0 * WAVE_LENGTH_SI * WAVE_LENGTH_SI / (4.0 * PI * PI * ::picongpu::SI::ELECTRON_MASS_SI * ::picongpu::SI::ELECTRON_MASS_SI * ::picongpu::SI::SPEED_OF_LIGHT_SI * ::picongpu::SI::SPEED_OF_LIGHT_SI * ::picongpu::SI::SPEED_OF_LIGHT_SI * ::picongpu::SI::SPEED_OF_LIGHT_SI * ::picongpu::SI::SPEED_OF_LIGHT_SI * ::picongpu::SI::EPS0_SI);
            const double UNITCONV_A0_to_Amplitude_SI = -2.0 * PI / WAVE_LENGTH_SI * ::picongpu::SI::ELECTRON_MASS_SI * ::picongpu::SI::SPEED_OF_LIGHT_SI * ::picongpu::SI::SPEED_OF_LIGHT_SI / ::picongpu::SI::ELECTRON_CHARGE_SI;

            /** unit: W / m^2 */
            //const double _PEAK_INTENSITY_SI = 3.4e19 * 1.0e4;
            /** unit: none */
            //const double _A0  = _PEAK_INTENSITY_SI * UNITCONV_Intens_to_A0;

            /** unit: none */
            const double _A0  = 0.1;

            /** unit: Volt /meter */
            const double AMPLITUDE_SI = _A0 * UNITCONV_A0_to_Amplitude_SI;

            /** unit: Volt /meter */
            //const double AMPLITUDE_SI = 1.738e13;

            /** Pulse length: sigma of std. gauss for intensity (E^2)
             *  PULSE_LENGTH_SI = FWHM_of_Intensity   / [ 2 * sqrt{ 2* ln(2) } ]
             *                                           2.3548200450309493820231386529194
             *  Info:             FWHM_of_Intensity = FWHM_Illumination
             *                      = what a experimentalist calls "pulse duration"
             *  unit: seconds (sigma) */
            const double PULSE_LENGTH_SI = 30.0e-15/2.354820045030949; //25.0e-15 / 1.17741;

            /** beam waist: distance from the axis where the pulse intensity (E^2)
             *              decreases to its 1/e^2-th part,
             *              at the focus position of the laser
             *  unit: meter */
            const double WX_SI = 20.0e-6;	// Cylindrically focused spot size
			const double WY_SI = 0.01;	// TWTS pulse width (this is usually mm or longer)
            /** the distance to the laser focus in y-direction
             *  unit: meter */
            const double FOCUS_POS_SI = 50.0e-6;
			/** interaction angle between TWTS laser propagation vector and the y-axis
             *  unit: rad */
			const double PHI_SI = 90. *(PI/180.);
			/** propagation speed of overlap normalized to the speed of light. [Default: beta0=1.0]
             *  unit: speed of light */
			const double BETA0_SI = 1.0;
			
        }
    }
}

/** Load external background fields
 *
 */
namespace picongpu
{
    class fieldBackgroundE
    {
    public:
        /* Add this additional field for pushing particles */
        static const bool InfluenceParticlePusher = ::picongpu::fieldBackground::includeTWTSlaser;

        /* We use this to calculate your SI input back to our unit system */
        const float3_64 unitField;
        HDINLINE fieldBackgroundE( const float3_64 unitField ) : unitField(unitField)
        {}

        /** Specify your background field E(r,t) here
         *
         * \param cellIdx The total cell id counted from the start at t=0
         * \param currentStep The current time step
		 * \param halfSimSize Center of simulation volume in number of cells */
        HDINLINE float3_X
        operator()( const DataSpace<simDim>& cellIdx,
                    const uint32_t currentStep,
					const DataSpace<simDim> halfSimSize	) const
        {
			const float_X focus_y = ::picongpu::fieldBackground::SI::FOCUS_POS_SI/SI::CELL_HEIGHT_SI;
			const float3_X helper = float3_X( halfSimSize.x(), focus_y, halfSimSize.z() );
		
			/* For the Yee-Cell shifted fields, obtain the fractional cell index components and add that to the total cell indices. The physical field coordinate origin is transversally centered with respect to the global simulation volume. */
			::PMacc::math::Vector<floatD_X,simDim> eFieldPositions = picongpu::yeeCell::YeeCell::getEFieldPosition();
			eFieldPositions[0] = ((float3_X)cellIdx+eFieldPositions[0]-helper) * float3_X(SI::CELL_WIDTH_SI,SI::CELL_HEIGHT_SI,SI::CELL_DEPTH_SI); // cellIdx(Ex)
			eFieldPositions[1] = ((float3_X)cellIdx+eFieldPositions[1]-helper) * float3_X(SI::CELL_WIDTH_SI,SI::CELL_HEIGHT_SI,SI::CELL_DEPTH_SI); // cellIdx(Ey)
			eFieldPositions[2] = ((float3_X)cellIdx+eFieldPositions[2]-helper) * float3_X(SI::CELL_WIDTH_SI,SI::CELL_HEIGHT_SI,SI::CELL_DEPTH_SI); // cellIdx(Ez)
			
			const float_X time=currentStep*SI::DELTA_T_SI+1;
		
            /* specify your E-Field in V/m and convert to PIConGPU units */
			if ( ! ::picongpu::fieldBackground::includeCollidingTWTS ) {
			// Single TWTS-Pulse
				return float3_X((::picongpu::fieldBackground::SI::AMPLITUDE_SI)*calcTWTSEx(eFieldPositions[0],time,halfSimSize,::picongpu::fieldBackground::SI::PHI_SI) / unitField[1],0.0, 0.0);
				//return float3_X((eFieldPositions[0]).x()/ unitField[1],(eFieldPositions[0]).y()/ unitField[1], time / unitField[1]);
			}
			else {
			// Colliding TWTS-Pulse
				return float3_X( (::picongpu::fieldBackground::SI::AMPLITUDE_SI)
								   *( calcTWTSEx(eFieldPositions[0],time,halfSimSize,+(::picongpu::fieldBackground::SI::PHI_SI))
									 +calcTWTSEx(eFieldPositions[0],time,halfSimSize,-(::picongpu::fieldBackground::SI::PHI_SI)) )
									/ unitField[1],0.0, 0.0);
			}
        }
		
		/** Calculate the Ex(r,t) field here
         *
         * \param pos Spatial position of the target field.
         * \param time Absolute time (SI, including all offsets and transformations) for calculating the field
		 * \param halfSimSize Center of simulation volume in number of cells
		 * \param phiReal interaction angle between TWTS laser propagation vector and the y-axis */
        HDINLINE float_X
        calcTWTSEx( const float3_X& pos, const float_X& time, const DataSpace<simDim> halfSimSize, const float_X& phiReal ) const
        {
			const numtype2 beta0=::picongpu::fieldBackground::SI::BETA0_SI; // propagation speed of overlap normalized to the speed of light. [Default: beta0=1.0]
			const numtype2 alphaTilt=atan2(1-beta0*cos(phiReal),beta0*sin(phiReal));
			const numtype2 phi=2*alphaTilt; // Definition of the laser pulse front tilt angle for the laser field below. For beta0=1.0, this is equivalent to our standard definition.
			const numtype2 eta = PI - phiReal + alphaTilt; // angle between the laser pulse front and the y-axis
			
			const numtype2 cspeed=::picongpu::SI::SPEED_OF_LIGHT_SI;
			const numtype2 lambda0=::picongpu::fieldBackground::SI::WAVE_LENGTH_SI;
			const numtype2 om0=2*PI*cspeed/lambda0;
			const numtype2 tauG=(::picongpu::fieldBackground::SI::PULSE_LENGTH_SI)*2.0; // factor 2 arises from definition convention in laser formula
			const numtype2 w0=::picongpu::fieldBackground::SI::WX_SI; // w0 is wx here --> w0 could be replaced by wx
			const numtype2 rho0=PI*w0*w0/lambda0;
			const numtype2 wy=::picongpu::fieldBackground::SI::WY_SI; // Width of TWTS pulse
			const numtype2 k=2*PI/lambda0;
			const numtype2 x=pos.x();
			const numtype2 y=-sin(phiReal)*pos.y()-cos(phiReal)*pos.z();	// RotationMatrix[PI-phiReal].(y,z)
			const numtype2 z=+cos(phiReal)*pos.y()-sin(phiReal)*pos.z();	// TO DO: For 2 counter-propagation TWTS pulses take +phiReal and -phiReal. Where do we implement this?
			const numtype2 y1=(float_X)(halfSimSize[2])/tan(eta); // halfSimSize[2] --> Half-depth of simulation volume (in z); By geometric projection we calculate the y-distance walkoff of the TWTS-pulse.
			const numtype2 m=3.; // Fudge parameter to make sure, that TWTS pulse starts to impact simulation volume at low intensity values.
			const numtype2 y2=(tauG/2*cspeed)/sin(eta)*m; // pulse length projected on y-axis, scaled with "fudge factor" m.
			const numtype2 y3=::picongpu::fieldBackground::SI::FOCUS_POS_SI; // Position of maximum intensity in simulation volume along y
			const numtype2 tdelay= (y1+y2+y3)/(cspeed*beta0);
			const numtype2 t=time-tdelay;
			
			const numtype2 exprDivInt_3_1=cspeed;
			const numtype2 exprDivInt_3_2=wy;
			const Complex exprDivInt_3_3=Complex(0,1)*rho0 - y*cos(phi) - z*sin(phi);
			const Complex exprDivInt_3_4=Complex(0,-1)*cspeed*om0*tauG*tauG - y*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.) - 2*z*tan(phi/2.)*tan(phi/2.);
			const Complex exprDivInt_3_5=Complex(0,1)*rho0 - y*cos(phi) - z*sin(phi);

			const Complex exprE_1_1=(
			-(cspeed*cspeed*k*om0*tauG*tauG*wy*wy*x*x)
			- 2*cspeed*cspeed*om0*t*t*wy*wy*rho0 
			+ Complex(0,2)*cspeed*cspeed*om0*om0*t*tauG*tauG*wy*wy*rho0
			- 2*cspeed*cspeed*om0*tauG*tauG*y*y*rho0
			+ 4*cspeed*om0*t*wy*wy*z*rho0
			- Complex(0,2)*cspeed*om0*om0*tauG*tauG*wy*wy*z*rho0
			- 2*om0*wy*wy*z*z*rho0
			- Complex(0,8)*om0*wy*wy*y*(cspeed*t - z)*z*sin(phi/2.)*sin(phi/2.)
			+ Complex(0,8)/sin(phi)*(
					+2*z*z*(cspeed*om0*t*wy*wy + Complex(0,1)*cspeed*y*y - om0*wy*wy*z)
					+ y*(
						+ cspeed*k*wy*wy*x*x
						- Complex(0,2)*cspeed*om0*t*wy*wy*rho0
						+ 2*cspeed*y*y*rho0
						+ Complex(0,2)*om0*wy*wy*z*rho0
					)*tan(PI/2-phi)/sin(phi)
				)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.)
			- Complex(0,2)*cspeed*cspeed*om0*t*t*wy*wy*z*sin(phi)
			- 2*cspeed*cspeed*om0*om0*t*tauG*tauG*wy*wy*z*sin(phi)
			- Complex(0,2)*cspeed*cspeed*om0*tauG*tauG*y*y*z*sin(phi)
			+ Complex(0,4)*cspeed*om0*t*wy*wy*z*z*sin(phi)
			+ 2*cspeed*om0*om0*tauG*tauG*wy*wy*z*z*sin(phi)
			- Complex(0,2)*om0*wy*wy*z*z*z*sin(phi)
			- 4*cspeed*om0*t*wy*wy*y*rho0*tan(phi/2.)
			+ 4*om0*wy*wy*y*z*rho0*tan(phi/2.)
			+ Complex(0,2)*y*y*(cspeed*om0*t*wy*wy + Complex(0,1)*cspeed*y*y - om0*wy*wy*z)*cos(phi)*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.)
			+ Complex(0,2)*cspeed*k*wy*wy*x*x*z*tan(phi/2.)*tan(phi/2.)
			- 2*om0*wy*wy*y*y*rho0*tan(phi/2.)*tan(phi/2.)
			+ 4*cspeed*om0*t*wy*wy*z*rho0*tan(phi/2.)*tan(phi/2.)
			+ Complex(0,4)*cspeed*y*y*z*rho0*tan(phi/2.)*tan(phi/2.)
			- 4*om0*wy*wy*z*z*rho0*tan(phi/2.)*tan(phi/2.)
			- Complex(0,2)*om0*wy*wy*y*y*z*sin(phi)*tan(phi/2.)*tan(phi/2.)
			- 2*y*cos(phi)*(om0*(cspeed*cspeed*(Complex(0,1)*t*t*wy*wy + om0*t*tauG*tauG*wy*wy + Complex(0,1)*tauG*tauG*y*y) - cspeed*(Complex(0,2)*t + om0*tauG*tauG)*wy*wy*z + Complex(0,1)*wy*wy*z*z) + Complex(0,2)*om0*wy*wy*y*(cspeed*t - z)*tan(phi/2.) + Complex(0,1)*(Complex(0,-4)*cspeed*y*y*z + om0*wy*wy*(y*y - 4*(cspeed*t - z)*z))*tan(phi/2.)*tan(phi/2.))
			)/(2.*exprDivInt_3_1*exprDivInt_3_2*exprDivInt_3_2*exprDivInt_3_3*exprDivInt_3_4);

			const Complex exprDivRat_1_1=cspeed*om0*tauG*tauG - Complex(0,8)*y*tan(PI/2-phi)/sin(phi)/sin(phi)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.) - Complex(0,2)*z*tan(phi/2.)*tan(phi/2.);
			const Complex result=(Complex::cexp(exprE_1_1)*tauG*Complex::csqrt((cspeed*om0*rho0)/exprDivInt_3_5))/Complex::csqrt(exprDivRat_1_1);			
            return result.get_real();
        }
		
		// /** Calculate the ExTest(r,t) field here
         // *
         // * \param pos Spatial position of the target field.
         // * \param time Absolute time (SI, including all offsets and transformations) for calculating the field
		 // * \param halfSimSize Center of simulation volume in number of cells
		 // * \param phiReal interaction angle between TWTS laser propagation vector and the y-axis */
        // HINLINE float_X
        // calcTWTSExTest( const float3_X& pos, const float_X& time, const DataSpace<simDim> halfSimSize, const float_X& phiReal ) const
        // {
			// std::cout << "============================================================" << std::endl;
			// std::cout << "Test TWTSEx" << std::endl << std::endl;
			
			// const numtype2 beta0=::picongpu::fieldBackground::SI::BETA0_SI; // propagation speed of overlap normalized to the speed of light. [Default: beta0=1.0]
			// const numtype2 alphaTilt=atan2(1-beta0*cos(phiReal),beta0*sin(phiReal));
			// const numtype2 phi=2*alphaTilt; // Definition of the laser pulse front tilt angle for the laser field below. For beta0=1.0, this is equivalent to our standard definition.
			// const numtype2 eta = PI - phiReal + alphaTilt; // angle between the laser pulse front and the y-axis
			
			// const numtype2 cspeed=::picongpu::SI::SPEED_OF_LIGHT_SI;
			// const numtype2 lambda0=::picongpu::fieldBackground::SI::WAVE_LENGTH_SI;
			// const numtype2 om0=2*PI*cspeed/lambda0;
			// const numtype2 tauG=(::picongpu::fieldBackground::SI::PULSE_LENGTH_SI)*2.0; // factor 2 arises from definition convention in laser formula
			// const numtype2 w0=::picongpu::fieldBackground::SI::WX_SI; // w0 is wx here --> w0 could be replaced by wx
			// const numtype2 rho0=PI*w0*w0/lambda0;
			// const numtype2 wy=::picongpu::fieldBackground::SI::WY_SI; // Width of TWTS pulse
			// const numtype2 k=2*PI/lambda0;
			// const numtype2 x=pos.x();
			// const numtype2 y=pos.y();//-sin(phiReal)*pos.y()-cos(phiReal)*pos.z();	// RotationMatrix[PI-phiReal].(y,z)
			// const numtype2 z=pos.z();//+cos(phiReal)*pos.y()-sin(phiReal)*pos.z();	// TO DO: For 2 counter-propagation TWTS pulses take +phiReal and -phiReal. Where do we implement this?
			// const numtype2 y1=(float_X)(halfSimSize[2])/tan(eta); // halfSimSize[2] --> Half-depth of simulation volume (in z); By geometric projection we calculate the y-distance walkoff of the TWTS-pulse.
			// const numtype2 m=3.; // Fudge parameter to make sure, that TWTS pulse starts to impact simulation volume at low intensity values.
			// const numtype2 y2=(tauG/2*cspeed)/sin(eta)*m; // pulse length projected on y-axis, scaled with "fudge factor" m.
			// const numtype2 y3=::picongpu::fieldBackground::SI::FOCUS_POS_SI; // Position of maximum intensity in simulation volume along y
			// const numtype2 tdelay= (y1+y2+y3)/(cspeed*beta0);
			// const numtype2 t=time;//-tdelay;
			
			// const numtype2 exprDivInt_3_1=cspeed;
			// const numtype2 exprDivInt_3_2=wy;
			// const Complex exprDivInt_3_3=Complex(0,1)*rho0 - y*cos(phi) - z*sin(phi);
			// const Complex exprDivInt_3_4=Complex(0,-1)*cspeed*om0*tauG*tauG - y*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.) - 2*z*tan(phi/2.)*tan(phi/2.);
			// const Complex exprDivInt_3_5=Complex(0,1)*rho0 - y*cos(phi) - z*sin(phi);

			// const Complex exprE_1_1=(
			// -(cspeed*cspeed*k*om0*tauG*tauG*wy*wy*x*x)
			// - 2*cspeed*cspeed*om0*t*t*wy*wy*rho0 
			// + Complex(0,2)*cspeed*cspeed*om0*om0*t*tauG*tauG*wy*wy*rho0
			// - 2*cspeed*cspeed*om0*tauG*tauG*y*y*rho0
			// + 4*cspeed*om0*t*wy*wy*z*rho0
			// - Complex(0,2)*cspeed*om0*om0*tauG*tauG*wy*wy*z*rho0
			// - 2*om0*wy*wy*z*z*rho0
			// - Complex(0,8)*om0*wy*wy*y*(cspeed*t - z)*z*sin(phi/2.)*sin(phi/2.)
			// + Complex(0,8)/sin(phi)*(
					// +2*z*z*(cspeed*om0*t*wy*wy + Complex(0,1)*cspeed*y*y - om0*wy*wy*z)
					// + y*(
						// + cspeed*k*wy*wy*x*x
						// - Complex(0,2)*cspeed*om0*t*wy*wy*rho0
						// + 2*cspeed*y*y*rho0
						// + Complex(0,2)*om0*wy*wy*z*rho0
					// )*tan(PI/2-phi)/sin(phi)
				// )*sin(phi/2.)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.)
			// - Complex(0,2)*cspeed*cspeed*om0*t*t*wy*wy*z*sin(phi)
			// - 2*cspeed*cspeed*om0*om0*t*tauG*tauG*wy*wy*z*sin(phi)
			// - Complex(0,2)*cspeed*cspeed*om0*tauG*tauG*y*y*z*sin(phi)
			// + Complex(0,4)*cspeed*om0*t*wy*wy*z*z*sin(phi)
			// + 2*cspeed*om0*om0*tauG*tauG*wy*wy*z*z*sin(phi)
			// - Complex(0,2)*om0*wy*wy*z*z*z*sin(phi)
			// - 4*cspeed*om0*t*wy*wy*y*rho0*tan(phi/2.)
			// + 4*om0*wy*wy*y*z*rho0*tan(phi/2.)
			// + Complex(0,2)*y*y*(cspeed*om0*t*wy*wy + Complex(0,1)*cspeed*y*y - om0*wy*wy*z)*cos(phi)*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.)
			// + Complex(0,2)*cspeed*k*wy*wy*x*x*z*tan(phi/2.)*tan(phi/2.)
			// - 2*om0*wy*wy*y*y*rho0*tan(phi/2.)*tan(phi/2.)
			// + 4*cspeed*om0*t*wy*wy*z*rho0*tan(phi/2.)*tan(phi/2.)
			// + Complex(0,4)*cspeed*y*y*z*rho0*tan(phi/2.)*tan(phi/2.)
			// - 4*om0*wy*wy*z*z*rho0*tan(phi/2.)*tan(phi/2.)
			// - Complex(0,2)*om0*wy*wy*y*y*z*sin(phi)*tan(phi/2.)*tan(phi/2.)
			// - 2*y*cos(phi)*(om0*(cspeed*cspeed*(Complex(0,1)*t*t*wy*wy + om0*t*tauG*tauG*wy*wy + Complex(0,1)*tauG*tauG*y*y) - cspeed*(Complex(0,2)*t + om0*tauG*tauG)*wy*wy*z + Complex(0,1)*wy*wy*z*z) + Complex(0,2)*om0*wy*wy*y*(cspeed*t - z)*tan(phi/2.) + Complex(0,1)*(Complex(0,-4)*cspeed*y*y*z + om0*wy*wy*(y*y - 4*(cspeed*t - z)*z))*tan(phi/2.)*tan(phi/2.))
			// )/(2.*exprDivInt_3_1*exprDivInt_3_2*exprDivInt_3_2*exprDivInt_3_3*exprDivInt_3_4);

			// const Complex exprDivRat_1_1=cspeed*om0*tauG*tauG - Complex(0,8)*y*tan(PI/2-phi)/sin(phi)/sin(phi)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.) - Complex(0,2)*z*tan(phi/2.)*tan(phi/2.);
			// const Complex result=(Complex::cexp(exprE_1_1)*tauG*fieldBackgroundE::csqrt((cspeed*om0*rho0)/exprDivInt_3_5))/fieldBackgroundE::csqrt(exprDivRat_1_1);
			
			// std::cout << "beta0: " << beta0 << std::endl;
			// std::cout << "alphaTilt: " << alphaTilt << std::endl;
			// std::cout << "phi: " << phi << std::endl;
			// std::cout << "eta: " << eta << std::endl;
			// std::cout << "cspeed: " << cspeed << std::endl;
			// std::cout << "lambda0: " << lambda0 << std::endl;
			// std::cout << "om0: " << om0 << std::endl;
			// std::cout << "tauG: " << tauG << std::endl;
			// std::cout << "w0: " << w0 << std::endl;
			// std::cout << "wy: " << wy << std::endl;
			// std::cout << "k: " << k << std::endl;
			// std::cout << "x: " << x << std::endl;
			// std::cout << "y: " << y << std::endl;
			// std::cout << "z: " << z << std::endl;
			// std::cout << "t: " << t << std::endl;
			// std::cout << "exprDivInt_3_1: " << exprDivInt_3_1 << std::endl;
			// std::cout << "exprDivInt_3_2: " << exprDivInt_3_2 << std::endl;
			// std::cout << "exprDivInt_3_3.re(): " << exprDivInt_3_3.get_real() << std::endl;
			// std::cout << "exprDivInt_3_3.im(): " << exprDivInt_3_3.get_imag() << std::endl;
			// std::cout << "exprDivInt_3_4.re(): " << exprDivInt_3_4.get_real() << std::endl;
			// std::cout << "exprDivInt_3_4.im(): " << exprDivInt_3_4.get_imag() << std::endl;
			// std::cout << "exprDivInt_3_5.re(): " << exprDivInt_3_5.get_real() << std::endl;
			// std::cout << "exprDivInt_3_5.im(): " << exprDivInt_3_5.get_imag() << std::endl;
			// std::cout << "exprE_1_1.re(): " << exprE_1_1.get_real() << std::endl;
			// std::cout << "exprE_1_1.im(): " << exprE_1_1.get_imag() << std::endl;
			// std::cout << "exprDivRat_1_1.re(): " << exprDivRat_1_1.get_real() << std::endl;
			// std::cout << "exprDivRat_1_1.im(): " << exprDivRat_1_1.get_imag() << std::endl;
			// std::cout << "result.re(): " << result.get_real() << std::endl;
			// std::cout << "result.im(): " << result.get_imag() << std::endl;
			// std::cout << "============================================================" << std::endl;
			
            // return result.get_real();
        // }
				
		// HINLINE static Complex csqrt(const Complex& other)
		// {
			// Complex helper = other;
			// std::cout << "csqrt(): helper.real() = "<< helper.get_real() << std::endl;
			// std::cout << "csqrt(): helper.imag() = "<< helper.get_imag() << std::endl;
			// std::cout << "csqrt(): helper.abs() = "<< helper.abs() << std::endl;
			// std::cout << "csqrt(): other.real() = "<< other.get_real() << std::endl;
			// std::cout << "csqrt(): other.imag() = "<< other.get_imag() << std::endl;
			// std::cout << "csqrt(): other.abs() = "<< other.abs() << std::endl;
			// if (other.get_real()<=0.0 && other.get_imag()==0.0) {
				// std::cout << "csqrt[re<=0;im=0.0] = I * " << sqrt(-helper.get_real()) << std::endl;
				// return Complex(0.0,sqrt(-helper.get_real()));
			// }
			// else {
				// std::cout << "csqrt[else].real() = " << (sqrt(fieldBackgroundE::abs(helper))*(other+fieldBackgroundE::abs(other))/fieldBackgroundE::abs(other+fieldBackgroundE::abs(other))).get_real() << std::endl;
				// std::cout << "csqrt[else].imag() = " << (sqrt(fieldBackgroundE::abs(helper))*(other+fieldBackgroundE::abs(other))/fieldBackgroundE::abs(other+fieldBackgroundE::abs(other))).get_imag() << std::endl;
				// return sqrt(fieldBackgroundE::abs(helper))*(other+fieldBackgroundE::abs(other))/fieldBackgroundE::abs(other+fieldBackgroundE::abs(other));
			// }
		// }
			
		// HINLINE static numtype2 abs(const Complex& other)
		// {
			// std::cout << "abs.real() = " << other.get_real() << std::endl;
			// std::cout << "abs.imag() = " << other.get_imag() << std::endl;
			// std::cout << "abs.res1() = " << (other.get_real()*other.get_real()+other.get_imag()*other.get_imag()) << std::endl;
			// std::cout << "abs.res2() = " << sqrt(other.get_real()*other.get_real()+other.get_imag()*other.get_imag()) << std::endl;
			// return sqrt(other.get_real()*other.get_real()+other.get_imag()*other.get_imag());
		// }
			
    };

    class fieldBackgroundB
    {
    public:
        /* Add this additional field for pushing particles */
        static const bool InfluenceParticlePusher = ::picongpu::fieldBackground::includeTWTSlaser;

        /* We use this to calculate your SI input back to our unit system */
        const float3_64 unitField;
        HDINLINE fieldBackgroundB( const float3_64 unitField ) : unitField(unitField)
        {}

        /** Specify your background field B(r,t) here
         *
         * \param cellIdx The total cell id counted from the start at t=0
         * \param currentStep The current time step
		 * \param halfSimSize Center of simulation volume in number of cells */
        HDINLINE float3_X
        operator()( const DataSpace<simDim>& cellIdx,
                    const uint32_t currentStep,
					const DataSpace<simDim> halfSimSize	) const
        {
			const float_X focus_y = 50.0e-6/SI::CELL_HEIGHT_SI;
			const float3_X helper = float3_X( halfSimSize.x(), focus_y, halfSimSize.z() );
			
			/* For the Yee-Cell shifted fields, obtain the fractional cell index components and add that to the total cell indices. The physical field coordinate origin is in the center of the simulation */
			::PMacc::math::Vector<floatD_X,simDim> bFieldPositions = picongpu::yeeCell::YeeCell::getBFieldPosition();
			bFieldPositions[0] = ((float3_X)cellIdx+bFieldPositions[0]-helper) * float3_X(SI::CELL_WIDTH_SI,SI::CELL_HEIGHT_SI,SI::CELL_DEPTH_SI); // cellIdx(Ex)
			bFieldPositions[1] = ((float3_X)cellIdx+bFieldPositions[1]-helper) * float3_X(SI::CELL_WIDTH_SI,SI::CELL_HEIGHT_SI,SI::CELL_DEPTH_SI); // cellIdx(Ey)
			bFieldPositions[2] = ((float3_X)cellIdx+bFieldPositions[2]-helper) * float3_X(SI::CELL_WIDTH_SI,SI::CELL_HEIGHT_SI,SI::CELL_DEPTH_SI); // cellIdx(Ez)
			
			const float_X time=currentStep*SI::DELTA_T_SI;
			
            /* specify your E-Field in V/m and convert to PIConGPU units */
			if ( ! ::picongpu::fieldBackground::includeCollidingTWTS ) {
				// Single TWTS-Pulse
				return float3_X(0.0, (::picongpu::fieldBackground::SI::AMPLITUDE_SI)*calcTWTSBy(bFieldPositions[1], time, halfSimSize, ::picongpu::fieldBackground::SI::PHI_SI) / unitField[1], (::picongpu::fieldBackground::SI::AMPLITUDE_SI)*calcTWTSBz(bFieldPositions[2], time, halfSimSize, ::picongpu::fieldBackground::SI::PHI_SI) / unitField[1]);
			}
			else {
				// Colliding TWTS-Pulse
				return float3_X(0.0, (::picongpu::fieldBackground::SI::AMPLITUDE_SI)
								*( calcTWTSBy(bFieldPositions[1], time, halfSimSize, +(::picongpu::fieldBackground::SI::PHI_SI))
								  +calcTWTSBy(bFieldPositions[1], time, halfSimSize, -(::picongpu::fieldBackground::SI::PHI_SI))
								)/ unitField[1]
						, (::picongpu::fieldBackground::SI::AMPLITUDE_SI)
								*( calcTWTSBz(bFieldPositions[2], time, halfSimSize, +(::picongpu::fieldBackground::SI::PHI_SI))
								  +calcTWTSBz(bFieldPositions[2], time, halfSimSize, -(::picongpu::fieldBackground::SI::PHI_SI))
								)/ unitField[1]);
			}
        }
		
		/** Calculate the By(r,t) field here
         *
         * \param pos Spatial position of the target field.
         * \param time Absolute time (SI, including all offsets and transformations) for calculating the field
		 * \param halfSimSize Center of simulation volume in number of cells
		 * \param phiReal interaction angle between TWTS laser propagation vector and the y-axis */
        HDINLINE float_X
        calcTWTSBy( const float3_X& pos, const float_X& time, const DataSpace<simDim> halfSimSize, const float_X& phiReal ) const
        {
			const numtype2 beta0=::picongpu::fieldBackground::SI::BETA0_SI; // propagation speed of overlap normalized to the speed of light. [Default: beta0=1.0]
			const numtype2 alphaTilt=atan2(1-beta0*cos(phiReal),beta0*sin(phiReal));
			const numtype2 phi=2*alphaTilt; // Definition of the laser pulse front tilt angle for the laser field below. For beta0=1.0, this is equivalent to our standard definition.
			const numtype2 eta = PI - phiReal + alphaTilt; // angle between the laser pulse front and the y-axis
			
			const numtype2 cspeed=::picongpu::SI::SPEED_OF_LIGHT_SI;
			const numtype2 lambda0=::picongpu::fieldBackground::SI::WAVE_LENGTH_SI;
			const numtype2 om0=2*PI*cspeed/lambda0;
			const numtype2 tauG=(::picongpu::fieldBackground::SI::PULSE_LENGTH_SI)*2.0; // factor 2 arises from definition convention in laser formula
			const numtype2 w0=::picongpu::fieldBackground::SI::WX_SI; // w0 is wx here --> w0 could be replaced by wx
			const numtype2 rho0=PI*w0*w0/lambda0;
			const numtype2 wy=::picongpu::fieldBackground::SI::WY_SI; // Width of TWTS pulse
			const numtype2 k=2*PI/lambda0;
			const numtype2 x=pos.x();
			const numtype2 y=-sin(phiReal)*pos.y()-cos(phiReal)*pos.z();	// RotationMatrix[PI-phiReal].(y,z)
			const numtype2 z=+cos(phiReal)*pos.y()-sin(phiReal)*pos.z();	// TO DO: For 2 counter-propagation TWTS pulses take +phiReal and -phiReal. Where do we implement this?
			const numtype2 y1=(float_X)(halfSimSize[2])/tan(eta); // halfSimSize[2] --> Half-depth of simulation volume (in z); By geometric projection we calculate the y-distance walkoff of the TWTS-pulse.
			const numtype2 m=3.; // Fudge parameter to make sure, that TWTS pulse starts to impact simulation volume at low intensity values.
			const numtype2 y2=(tauG/2*cspeed)/sin(eta)*m; // pulse length projected on y-axis, scaled with "fudge factor" m.
			const numtype2 y3=::picongpu::fieldBackground::SI::FOCUS_POS_SI; // Position of maximum intensity in simulation volume along y
			const numtype2 tdelay= (y1+y2+y3)/(cspeed*beta0);
			const numtype2 t=time-tdelay;
			
			const numtype2 exprDivInt_3_1=cspeed;
			const numtype2 exprDivInt_3_2=wy;
			const Complex exprDivInt_3_3=rho0 + Complex(0,1)*y*cos(phi) + Complex(0,1)*z*sin(phi);
			const Complex exprDivInt_3_4=cspeed*om0*tauG*tauG + Complex(0,2)*(-z - y*tan(PI/2-phi))*tan(phi/2.)*tan(phi/2.);
			const numtype2 exprDivInt_3_5=2;
			const numtype2 exprDivInt_3_6=rho0;
			const Complex exprDivInt_2_1=Complex(0,1)*rho0 - y*cos(phi) - z*sin(phi);
			const Complex exprE_1_1=-1.0*(
			cspeed*cspeed*k*om0*tauG*tauG*wy*wy*x*x
			+ 2*cspeed*cspeed*om0*t*t*wy*wy*rho0
			- Complex(0,2)*cspeed*cspeed*om0*om0*t*tauG*tauG*wy*wy*rho0
			+ 2*cspeed*cspeed*om0*tauG*tauG*y*y*rho0
			- 4*cspeed*om0*t*wy*wy*z*rho0
			+ Complex(0,2)*cspeed*om0*om0*tauG*tauG*wy*wy*z*rho0
			+ 2*om0*wy*wy*z*z*rho0
			+ 4*cspeed*om0*t*wy*wy*y*rho0*tan(phi/2.)
			- 4*om0*wy*wy*y*z*rho0*tan(phi/2.)
			- Complex(0,2)*cspeed*k*wy*wy*x*x*z*tan(phi/2.)*tan(phi/2.)
			+ 2*om0*wy*wy*y*y*rho0*tan(phi/2.)*tan(phi/2.)
			- 4*cspeed*om0*t*wy*wy*z*rho0*tan(phi/2.)*tan(phi/2.)
			- Complex(0,4)*cspeed*y*y*z*rho0*tan(phi/2.)*tan(phi/2.)
			+ 4*om0*wy*wy*z*z*rho0*tan(phi/2.)*tan(phi/2.)
			- Complex(0,2)*cspeed*k*wy*wy*x*x*y*tan(PI/2-phi)*tan(phi/2.)*tan(phi/2.)
			- 4*cspeed*om0*t*wy*wy*y*rho0*tan(PI/2-phi)*tan(phi/2.)*tan(phi/2.)
			- Complex(0,4)*cspeed*y*y*y*rho0*tan(PI/2-phi)*tan(phi/2.)*tan(phi/2.)
			+ 4*om0*wy*wy*y*z*rho0*tan(PI/2-phi)*tan(phi/2.)*tan(phi/2.)
			+ 2*z*sin(phi)*(
				om0*(cspeed*cspeed*(Complex(0,1)*t*t*wy*wy + om0*t*tauG*tauG*wy*wy + Complex(0,1)*tauG*tauG*y*y) - cspeed*(Complex(0,2)*t + om0*tauG*tauG)*wy*wy*z + Complex(0,1)*wy*wy*z*z)
				+ Complex(0,2)*om0*wy*wy*y*(cspeed*t - z)*tan(phi/2.) + Complex(0,1)*(Complex(0,-2)*cspeed*y*y*z + om0*wy*wy*(y*y - 2*(cspeed*t - z)*z))*tan(phi/2.)*tan(phi/2.)
				)
			+ 2*y*cos(phi)*(
				om0*(cspeed*cspeed*(Complex(0,1)*t*t*wy*wy + om0*t*tauG*tauG*wy*wy + Complex(0,1)*tauG*tauG*y*y) - cspeed*(Complex(0,2)*t + om0*tauG*tauG)*wy*wy*z + Complex(0,1)*wy*wy*z*z)
				+ Complex(0,2)*om0*wy*wy*y*(cspeed*t - z)*tan(phi/2.)
				+ Complex(0,1)*(Complex(0,-4)*cspeed*y*y*z + om0*wy*wy*(y*y - 4*(cspeed*t - z)*z) - 2*y*(cspeed*om0*t*wy*wy + Complex(0,1)*cspeed*y*y - om0*wy*wy*z)*tan(PI/2-phi))*tan(phi/2.)*tan(phi/2.)
				)
			)/(2.*exprDivInt_3_1*exprDivInt_3_2*exprDivInt_3_2*exprDivInt_3_3*exprDivInt_3_4);

			const Complex exprDivInt_1_1=Complex(0,-1)*cspeed*om0*tauG*tauG + (-z - y*tan(PI/2-phi))*tan(phi/2.)*tan(phi/2.)*exprDivInt_3_5;
			const Complex exprDivRat_1_1=(cspeed*(cspeed*om0*tauG*tauG + Complex(0,2)*(-z - y*tan(PI/2-phi))*tan(phi/2.)*tan(phi/2.)))/(om0*exprDivInt_3_6);
			const Complex result=(Complex::cexp(exprE_1_1)*tauG/cos(phi/2.)/cos(phi/2.)*(rho0 + Complex(0,1)*y*cos(phi) + Complex(0,1)*z*sin(phi))*(Complex(0,2)*cspeed*t + cspeed*om0*tauG*tauG - Complex(0,4)*z + cspeed*(Complex(0,2)*t + om0*tauG*tauG)*cos(phi) + Complex(0,2)*y*tan(phi/2.))*Complex::csqrt(1.0/exprDivInt_2_1*exprDivInt_2_1*exprDivInt_2_1))/(2.*exprDivInt_1_1*Complex::csqrt(exprDivRat_1_1));

            return result.get_real();
        }
	

        /** Calculate the Bz(r,t) field here
         *
         * \param pos Spatial position of the target field.
         * \param time Absolute time (SI, including all offsets and transformations) for calculating the field
		 * \param halfSimSize Center of simulation volume in number of cells
		 * \param phiReal interaction angle between TWTS laser propagation vector and the y-axis */
        HDINLINE float_X
        calcTWTSBz( const float3_X& pos, const float_X& time, const DataSpace<simDim> halfSimSize, const float_X& phiReal ) const
        {
			const numtype2 beta0=::picongpu::fieldBackground::SI::BETA0_SI; // propagation speed of overlap normalized to the speed of light. [Default: beta0=1.0]
			const numtype2 alphaTilt=atan2(1-beta0*cos(phiReal),beta0*sin(phiReal));
			const numtype2 phi=2*alphaTilt; // Definition of the laser pulse front tilt angle for the laser field below. For beta0=1.0, this is equivalent to our standard definition.
			const numtype2 eta = PI - phiReal + alphaTilt; // angle between the laser pulse front and the y-axis
			
			const numtype2 cspeed=::picongpu::SI::SPEED_OF_LIGHT_SI;
			const numtype2 lambda0=::picongpu::fieldBackground::SI::WAVE_LENGTH_SI;
			const numtype2 om0=2*PI*cspeed/lambda0;
			const numtype2 tauG=(::picongpu::fieldBackground::SI::PULSE_LENGTH_SI)*2.0; // factor 2 arises from definition convention in laser formula
			const numtype2 w0=::picongpu::fieldBackground::SI::WX_SI; // w0 is wx here --> w0 could be replaced by wx
			const numtype2 rho0=PI*w0*w0/lambda0;
			const numtype2 wy=::picongpu::fieldBackground::SI::WY_SI; // Width of TWTS pulse
			const numtype2 k=2*PI/lambda0;
			const numtype2 x=pos.x();
			const numtype2 y=-sin(phiReal)*pos.y()-cos(phiReal)*pos.z();	// RotationMatrix[PI-phiReal].(y,z)
			const numtype2 z=+cos(phiReal)*pos.y()-sin(phiReal)*pos.z();	// TO DO: For 2 counter-propagation TWTS pulses take +phiReal and -phiReal. Where do we implement this?
			const numtype2 y1=(float_X)(halfSimSize[2])/tan(eta); // halfSimSize[2] --> Half-depth of simulation volume (in z); By geometric projection we calculate the y-distance walkoff of the TWTS-pulse.
			const numtype2 m=3.; // Fudge parameter to make sure, that TWTS pulse starts to impact simulation volume at low intensity values.
			const numtype2 y2=(tauG/2*cspeed)/sin(eta)*m; // pulse length projected on y-axis, scaled with "fudge factor" m.
			const numtype2 y3=::picongpu::fieldBackground::SI::FOCUS_POS_SI; // Position of maximum intensity in simulation volume along y
			const numtype2 tdelay= (y1+y2+y3)/(cspeed*beta0);
			const numtype2 t=time-tdelay;
			
			const Complex exprDivInt_5_1=-(cspeed*z) - cspeed*y*tan(PI/2-phi) + Complex(0,1)*cspeed*rho0/sin(phi);
			const Complex exprDivInt_5_2=Complex(0,1)*rho0 - y*cos(phi) - z*sin(phi);
			const numtype2 exprDivInt_5_4=wy;
			const Complex exprDivInt_5_12=exprDivInt_5_2*cspeed;
			const numtype2 exprDivInt_5_18=cspeed;
			const Complex exprDivInt_5_19=cspeed*om0*tauG*tauG - Complex(0,1)*y*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.) - Complex(0,2)*z*tan(phi/2.)*tan(phi/2.);
			const Complex exprPower=2*cspeed*t - Complex(0,1)*cspeed*om0*tauG*tauG - 2*z + 8*y/sin(phi)/sin(phi)/sin(phi)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.) - 2*z*tan(phi/2.)*tan(phi/2.);

			const Complex exprE_1_1=(
			(om0*y*rho0/cos(phi/2.)/cos(phi/2.)/cos(phi/2.)/cos(phi/2.))/exprDivInt_5_1 
			- (Complex(0,2)*k*x*x)/exprDivInt_5_2 
			- (Complex(0,1)*om0*om0*tauG*tauG*rho0)/exprDivInt_5_2
			- (Complex(0,4)*y*y*rho0)/(exprDivInt_5_4*exprDivInt_5_4*exprDivInt_5_2)
			+ (om0*om0*tauG*tauG*y*cos(phi))/exprDivInt_5_2
			+ (4*y*y*y*cos(phi))/(exprDivInt_5_4*exprDivInt_5_4*exprDivInt_5_2)
			+ (om0*om0*tauG*tauG*z*sin(phi))/exprDivInt_5_2
			+ (4*y*y*z*sin(phi))/(exprDivInt_5_4*exprDivInt_5_4*exprDivInt_5_2)
			+ (Complex(0,2)*om0*y*y*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.))/exprDivInt_5_12
			+ (om0*y*rho0*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.))/exprDivInt_5_12
			+ (Complex(0,1)*om0*y*y*cos(phi)*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.))/exprDivInt_5_12
			+ (Complex(0,4)*om0*y*z*tan(phi/2.)*tan(phi/2.))/exprDivInt_5_12
			- (2*om0*z*rho0*tan(phi/2.)*tan(phi/2.))/exprDivInt_5_12
			- (Complex(0,2)*om0*z*z*sin(phi)*tan(phi/2.)*tan(phi/2.))/exprDivInt_5_12
			- (om0*exprPower*exprPower)/(exprDivInt_5_18*exprDivInt_5_19)
			)/4.;
					
			const Complex exprDivRat_1_1=cspeed*om0*tauG*tauG - Complex(0,1)*y*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.) - Complex(0,2)*z*tan(phi/2.)*tan(phi/2.);
			const Complex result=(Complex(0,2)*Complex::cexp(exprE_1_1)*tauG*tan(phi/2.)*(cspeed*t - z + y*tan(phi/2.))*Complex::csqrt((om0*rho0)/exprDivInt_5_12))/Complex::csqrt(exprDivRat_1_1*exprDivRat_1_1*exprDivRat_1_1);

            return result.get_real();
        }
		
    };

    class fieldBackgroundJ
    {
    public:
        /* Add this additional field? */
        static const bool activated = false;

        /* We use this to calculate your SI input back to our unit system */
        const float3_64 unitField;
        HDINLINE fieldBackgroundJ( const float3_64 unitField ) : unitField(unitField)
        {}

        /** Specify your background field J(r,t) here
         *
         * \param cellIdx The total cell id counted from the start at t=0
         * \param currentStep The current time step
		 * \param halfSimSize Center of simulation volume in number of cells */
        HDINLINE float3_X
        operator()( const DataSpace<simDim>& cellIdx,
                    const uint32_t currentStep,
					const DataSpace<simDim> halfSimSize	) const
        {
            /* example: periodicity of 20 microns (=2.0e-5 m) */
            const float_64 period_SI(20.0e-6);
            /* calculate cells -> SI -> m to microns*/
            const float_64 y_SI = cellIdx.y() * SI::CELL_HEIGHT_SI * 1.0e6;
            /* note: you can also transform the time step to seconds by
             *       multiplying with DELTA_T_SI */

            /* specify your J-Field in A/m^2 and convert to PIConGPU units */
            const float_X sinArg = precisionCast<float_X>( y_SI / period_SI * 2.0 * PI );
            return float3_X(0.0, math::cos( sinArg ) / unitField[1], 0.0);
        }
    };

} // namespace picongpu
