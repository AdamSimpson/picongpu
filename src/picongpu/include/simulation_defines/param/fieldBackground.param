/**
 * Copyright 2014 Alexander Debus, Axel Huebl
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once
#include "../../plugins/radiation/complex.hpp"
#include "../../fields/numericalCellTypes/YeeCell.hpp"
#include "math/Vector.hpp"

/** Load external background fields
 *
 */
namespace picongpu
{
    class fieldBackgroundE
    {
    public:
        /* Add this additional field for pushing particles */
        static const bool InfluenceParticlePusher = false;

        /* We use this to calculate your SI input back to our unit system */
        const float3_64 unitField;
        HDINLINE fieldBackgroundE( const float3_64 unitField ) : unitField(unitField)
        {}

        /** Specify your background field E(r,t) here
         *
         * \param cellIdx The total cell id counted from the start at t=0
         * \param currentStep The current time step */
        HDINLINE float3_X
        operator()( const DataSpace<simDim>& cellIdx,
                    const uint32_t currentStep ) const
        {
			/* For the Yee-Cell shifted fields, obtain the fractional cell index components and add that to the total cell indices. The physical field coordinate origin is in the center of the simulation */
			::PMacc::math::Vector<floatD_X,simDim> eFieldPositions = picongpu::yeeCell::YeeCell::getEFieldPosition();
		    const SubGrid<simDim>& subGrid = Environment<simDim>::get().SubGrid();
			const DataSpace<simDim> halfSimSize(subGrid.getGlobalDomain().size / 2);
			eFieldPositions[0] = ((float3_X)cellIdx+eFieldPositions[0]-(float3_X)halfSimSize) * float3_X(SI::CELL_WIDTH_SI,SI::CELL_HEIGHT_SI,SI::CELL_DEPTH_SI); // cellIdx(Ex)
			eFieldPositions[1] = ((float3_X)cellIdx+eFieldPositions[1]-(float3_X)halfSimSize) * float3_X(SI::CELL_WIDTH_SI,SI::CELL_HEIGHT_SI,SI::CELL_DEPTH_SI); // cellIdx(Ey)
			eFieldPositions[2] = ((float3_X)cellIdx+eFieldPositions[2]-(float3_X)halfSimSize) * float3_X(SI::CELL_WIDTH_SI,SI::CELL_HEIGHT_SI,SI::CELL_DEPTH_SI); // cellIdx(Ez)
			
			const float_X time=currentStep*SI::DELTA_T_SI;

			
			// To do: Transform coordinates (1.) Rotate coordinate system. (2.) Shift time.)
			
			// To do: Obtain parameters
			
            /* specify your E-Field in V/m and convert to PIConGPU units */
            return float3_X(calcTWTSEx(eFieldPositions[0],time) / unitField[1],0.0, 0.0);
        }
		
		/** Calculate the Ex(r,t) field here
         *
         * \param pos Spatial position of the target field.
         * \param time Absolute time (SI, including all offsets and transformations) for calculating the field */
        HDINLINE float_X
        calcTWTSEx( const float3_X& pos, const float_X& time ) const
        {
			const numtype2 phi=1.0;
			const numtype2 om0=1.0;
			const numtype2 tauG=1.0;
			const numtype2 rho0=1.0;
			const numtype2 wy=1.0;
			const numtype2 k=1.0;
			const numtype2 cspeed=1.0;
			const numtype2 x=pos.x();
			const numtype2 y=pos.y();
			const numtype2 z=pos.z();
			const numtype2 t=time;
			
			const numtype2 exprDivInt_3_1=cspeed;
			const numtype2 exprDivInt_3_2=wy;
			const Complex exprDivInt_3_3=Complex(0,1)*rho0 - y*cos(phi) - z*sin(phi);
			const Complex exprDivInt_3_4=Complex(0,-1)*cspeed*om0*tauG*tauG - y*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.) - 2*z*tan(phi/2.)*tan(phi/2.);
			const Complex exprDivInt_3_5=Complex(0,1)*rho0 - y*cos(phi) - z*sin(phi);

			const Complex exprE_1_1=(
			-(cspeed*cspeed*k*om0*tauG*tauG*wy*wy*x*x)
			- 2*cspeed*cspeed*om0*t*t*wy*wy*rho0 
			+ Complex(0,2)*cspeed*cspeed*om0*om0*t*tauG*tauG*wy*wy*rho0
			- 2*cspeed*cspeed*om0*tauG*tauG*y*y*rho0
			+ 4*cspeed*om0*t*wy*wy*z*rho0
			- Complex(0,2)*cspeed*om0*om0*tauG*tauG*wy*wy*z*rho0
			- 2*om0*wy*wy*z*z*rho0
			- Complex(0,8)*om0*wy*wy*y*(cspeed*t - z)*z*sin(phi/2.)*sin(phi/2.)
			+ Complex(0,8)/sin(phi)*(
					+2*z*z*(cspeed*om0*t*wy*wy + Complex(0,1)*cspeed*y*y - om0*wy*wy*z)
					+ y*(
						+ cspeed*k*wy*wy*x*x
						- Complex(0,2)*cspeed*om0*t*wy*wy*rho0
						+ 2*cspeed*y*y*rho0
						+ Complex(0,2)*om0*wy*wy*z*rho0
					)/tan(phi)/sin(phi)
				)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.)
			- Complex(0,2)*cspeed*cspeed*om0*t*t*wy*wy*z*sin(phi)
			- 2*cspeed*cspeed*om0*om0*t*tauG*tauG*wy*wy*z*sin(phi)
			- Complex(0,2)*cspeed*cspeed*om0*tauG*tauG*y*y*z*sin(phi)
			+ Complex(0,4)*cspeed*om0*t*wy*wy*z*z*sin(phi)
			+ 2*cspeed*om0*om0*tauG*tauG*wy*wy*z*z*sin(phi)
			- Complex(0,2)*om0*wy*wy*z*z*z*sin(phi)
			- 4*cspeed*om0*t*wy*wy*y*rho0*tan(phi/2.)
			+ 4*om0*wy*wy*y*z*rho0*tan(phi/2.)
			+ Complex(0,2)*y*y*(cspeed*om0*t*wy*wy + Complex(0,1)*cspeed*y*y - om0*wy*wy*z)*cos(phi)*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.)
			+ Complex(0,2)*cspeed*k*wy*wy*x*x*z*tan(phi/2.)*tan(phi/2.)
			- 2*om0*wy*wy*y*y*rho0*tan(phi/2.)*tan(phi/2.)
			+ 4*cspeed*om0*t*wy*wy*z*rho0*tan(phi/2.)*tan(phi/2.)
			+ Complex(0,4)*cspeed*y*y*z*rho0*tan(phi/2.)*tan(phi/2.)
			- 4*om0*wy*wy*z*z*rho0*tan(phi/2.)*tan(phi/2.)
			- Complex(0,2)*om0*wy*wy*y*y*z*sin(phi)*tan(phi/2.)*tan(phi/2.)
			- 2*y*cos(phi)*(om0*(cspeed*cspeed*(Complex(0,1)*t*t*wy*wy + om0*t*tauG*tauG*wy*wy + Complex(0,1)*tauG*tauG*y*y) - cspeed*(Complex(0,2)*t + om0*tauG*tauG)*wy*wy*z + Complex(0,1)*wy*wy*z*z) + Complex(0,2)*om0*wy*wy*y*(cspeed*t - z)*tan(phi/2.) + Complex(0,1)*(Complex(0,-4)*cspeed*y*y*z + om0*wy*wy*(y*y - 4*(cspeed*t - z)*z))*tan(phi/2.)*tan(phi/2.))
			)/(2.*exprDivInt_3_1*exprDivInt_3_2*exprDivInt_3_2*exprDivInt_3_3*exprDivInt_3_4);

			const Complex exprDivRat_1_1=cspeed*om0*tauG*tauG - Complex(0,8)*y/tan(phi)/sin(phi)/sin(phi)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.) - Complex(0,2)*z*tan(phi/2.)*tan(phi/2.);
			const Complex result=(Complex::cexp(exprE_1_1)*tauG*Complex::csqrt((cspeed*om0*rho0)/exprDivInt_3_5))/Complex::csqrt(exprDivRat_1_1);			
            return 2*result.get_real();
        }
		
    };

    class fieldBackgroundB
    {
    public:
        /* Add this additional field for pushing particles */
        static const bool InfluenceParticlePusher = false;

        /* We use this to calculate your SI input back to our unit system */
        const float3_64 unitField;
        HDINLINE fieldBackgroundB( const float3_64 unitField ) : unitField(unitField)
        {}

        /** Specify your background field B(r,t) here
         *
         * \param cellIdx The total cell id counted from the start at t=0
         * \param currentStep The current time step */
        HDINLINE float3_X
        operator()( const DataSpace<simDim>& cellIdx,
                    const uint32_t currentStep ) const
        {
			/* For the Yee-Cell shifted fields, obtain the fractional cell index components and add that to the total cell indices. The physical field coordinate origin is in the center of the simulation */
			::PMacc::math::Vector<floatD_X,simDim> bFieldPositions = picongpu::yeeCell::YeeCell::getBFieldPosition();
		    const SubGrid<simDim>& subGrid = Environment<simDim>::get().SubGrid();
			const DataSpace<simDim> globalCellOffset(subGrid.getLocalDomain().offset);
			const DataSpace<simDim> halfSimSize(subGrid.getGlobalDomain().size / 2);
			bFieldPositions[0] = ((float3_X)cellIdx+bFieldPositions[0]-(float3_X)halfSimSize) * float3_X(SI::CELL_WIDTH_SI,SI::CELL_HEIGHT_SI,SI::CELL_DEPTH_SI); // cellIdx(Ex)
			bFieldPositions[1] = ((float3_X)cellIdx+bFieldPositions[1]-(float3_X)halfSimSize) * float3_X(SI::CELL_WIDTH_SI,SI::CELL_HEIGHT_SI,SI::CELL_DEPTH_SI); // cellIdx(Ey)
			bFieldPositions[2] = ((float3_X)cellIdx+bFieldPositions[2]-(float3_X)halfSimSize) * float3_X(SI::CELL_WIDTH_SI,SI::CELL_HEIGHT_SI,SI::CELL_DEPTH_SI); // cellIdx(Ez)
			
			const float_X time=currentStep*SI::DELTA_T_SI;

			
			// To do: Transform coordinates (1.) Rotate coordinate system. (2.) Shift time.)
			
			// To do: Obtain parameters
			
            /* specify your E-Field in V/m and convert to PIConGPU units */
            return float3_X(0.0, calcTWTSBy(bFieldPositions[1],time) / unitField[1], calcTWTSBz(bFieldPositions[2],time) / unitField[1]);
        }
		
		/** Calculate the By(r,t) field here
         *
         * \param pos Spatial position of the target field.
         * \param time Absolute time (SI, including all offsets and transformations) for calculating the field */
        HDINLINE float_X
        calcTWTSBy( const float3_X& pos, const float_X& time ) const
        {
			const numtype2 phi=1.0;
			const numtype2 om0=1.0;
			const numtype2 tauG=1.0;
			const numtype2 rho0=1.0;
			const numtype2 cspeed=1.0;
			const numtype2 wy=1.0;
			const numtype2 k=1.0;
			const numtype2 x=pos.x();
			const numtype2 y=pos.y();
			const numtype2 z=pos.z();
			const numtype2 t=time;
			
			const numtype2 exprDivInt_3_1=cspeed;
			const numtype2 exprDivInt_3_2=wy;
			const Complex exprDivInt_3_3=rho0 + Complex(0,1)*y*cos(phi) + Complex(0,1)*z*sin(phi);
			const Complex exprDivInt_3_4=cspeed*om0*tauG*tauG + Complex(0,2)*(-z - y/tan(phi))*tan(phi/2.)*tan(phi/2.);
			const numtype2 exprDivInt_3_5=2;
			const numtype2 exprDivInt_3_6=rho0;
			const Complex exprDivInt_2_1=Complex(0,1)*rho0 - y*cos(phi) - z*sin(phi);
			const Complex exprE_1_1=-1.0*(
			cspeed*cspeed*k*om0*tauG*tauG*wy*wy*x*x
			+ 2*cspeed*cspeed*om0*t*t*wy*wy*rho0
			- Complex(0,2)*cspeed*cspeed*om0*om0*t*tauG*tauG*wy*wy*rho0
			+ 2*cspeed*cspeed*om0*tauG*tauG*y*y*rho0
			- 4*cspeed*om0*t*wy*wy*z*rho0
			+ Complex(0,2)*cspeed*om0*om0*tauG*tauG*wy*wy*z*rho0
			+ 2*om0*wy*wy*z*z*rho0
			+ 4*cspeed*om0*t*wy*wy*y*rho0*tan(phi/2.)
			- 4*om0*wy*wy*y*z*rho0*tan(phi/2.)
			- Complex(0,2)*cspeed*k*wy*wy*x*x*z*tan(phi/2.)*tan(phi/2.)
			+ 2*om0*wy*wy*y*y*rho0*tan(phi/2.)*tan(phi/2.)
			- 4*cspeed*om0*t*wy*wy*z*rho0*tan(phi/2.)*tan(phi/2.)
			- Complex(0,4)*cspeed*y*y*z*rho0*tan(phi/2.)*tan(phi/2.)
			+ 4*om0*wy*wy*z*z*rho0*tan(phi/2.)*tan(phi/2.)
			- Complex(0,2)*cspeed*k*wy*wy*x*x*y/tan(phi)*tan(phi/2.)*tan(phi/2.)
			- 4*cspeed*om0*t*wy*wy*y*rho0/tan(phi)*tan(phi/2.)*tan(phi/2.)
			- Complex(0,4)*cspeed*y*y*y*rho0/tan(phi)*tan(phi/2.)*tan(phi/2.)
			+ 4*om0*wy*wy*y*z*rho0/tan(phi)*tan(phi/2.)*tan(phi/2.)
			+ 2*z*sin(phi)*(
				om0*(cspeed*cspeed*(Complex(0,1)*t*t*wy*wy + om0*t*tauG*tauG*wy*wy + Complex(0,1)*tauG*tauG*y*y) - cspeed*(Complex(0,2)*t + om0*tauG*tauG)*wy*wy*z + Complex(0,1)*wy*wy*z*z)
				+ Complex(0,2)*om0*wy*wy*y*(cspeed*t - z)*tan(phi/2.) + Complex(0,1)*(Complex(0,-2)*cspeed*y*y*z + om0*wy*wy*(y*y - 2*(cspeed*t - z)*z))*tan(phi/2.)*tan(phi/2.)
				)
			+ 2*y*cos(phi)*(
				om0*(cspeed*cspeed*(Complex(0,1)*t*t*wy*wy + om0*t*tauG*tauG*wy*wy + Complex(0,1)*tauG*tauG*y*y) - cspeed*(Complex(0,2)*t + om0*tauG*tauG)*wy*wy*z + Complex(0,1)*wy*wy*z*z)
				+ Complex(0,2)*om0*wy*wy*y*(cspeed*t - z)*tan(phi/2.)
				+ Complex(0,1)*(Complex(0,-4)*cspeed*y*y*z + om0*wy*wy*(y*y - 4*(cspeed*t - z)*z) - 2*y*(cspeed*om0*t*wy*wy + Complex(0,1)*cspeed*y*y - om0*wy*wy*z)/tan(phi))*tan(phi/2.)*tan(phi/2.)
				)
			)/(2.*exprDivInt_3_1*exprDivInt_3_2*exprDivInt_3_2*exprDivInt_3_3*exprDivInt_3_4);

			const Complex exprDivInt_1_1=Complex(0,-1)*cspeed*om0*tauG*tauG + (-z - y/tan(phi))*tan(phi/2.)*tan(phi/2.)*exprDivInt_3_5;
			const Complex exprDivRat_1_1=(cspeed*(cspeed*om0*tauG*tauG + Complex(0,2)*(-z - y/tan(phi))*tan(phi/2.)*tan(phi/2.)))/(om0*exprDivInt_3_6);
			const Complex result=(Complex::cexp(exprE_1_1)*tauG/cos(phi/2.)/cos(phi/2.)*(rho0 + Complex(0,1)*y*cos(phi) + Complex(0,1)*z*sin(phi))*(Complex(0,2)*cspeed*t + cspeed*om0*tauG*tauG - Complex(0,4)*z + cspeed*(Complex(0,2)*t + om0*tauG*tauG)*cos(phi) + Complex(0,2)*y*tan(phi/2.))*Complex::csqrt(1.0/exprDivInt_2_1*exprDivInt_2_1*exprDivInt_2_1))/(2.*exprDivInt_1_1*Complex::csqrt(exprDivRat_1_1));

            return float_X( 2*result.get_real() );
        }
	

        /** Calculate the Bz(r,t) field here
         *
         * \param pos Spatial position of the target field.
         * \param time Absolute time (SI, including all offsets and transformations) for calculating the field */
        HDINLINE float_X
        calcTWTSBz( const float3_X& pos, const float_X& time ) const
        {
			const numtype2 phi=1.0;
			const numtype2 om0=1.0;
			const numtype2 tauG=1.0;
			const numtype2 rho0=1.0;
			const numtype2 cspeed=1.0;
			const numtype2 wy=1.0;
			const numtype2 k=1.0;
			const numtype2 x=pos.x();
			const numtype2 y=pos.y();
			const numtype2 z=pos.z();
			const numtype2 t=time;
			
			const Complex exprDivInt_5_1=-(cspeed*z) - cspeed*y/tan(phi) + Complex(0,1)*cspeed*rho0/sin(phi);
			const Complex exprDivInt_5_2=Complex(0,1)*rho0 - y*cos(phi) - z*sin(phi);
			const numtype2 exprDivInt_5_4=wy;
			const Complex exprDivInt_5_12=exprDivInt_5_2*cspeed;
			const numtype2 exprDivInt_5_18=cspeed;
			const Complex exprDivInt_5_19=cspeed*om0*tauG*tauG - Complex(0,1)*y*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.) - Complex(0,2)*z*tan(phi/2.)*tan(phi/2.);
			const Complex exprPower=2*cspeed*t - Complex(0,1)*cspeed*om0*tauG*tauG - 2*z + 8*y/sin(phi)/sin(phi)/sin(phi)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.)*sin(phi/2.) - 2*z*tan(phi/2.)*tan(phi/2.);

			const Complex exprE_1_1=(
			(om0*y*rho0/cos(phi/2.)/cos(phi/2.)/cos(phi/2.)/cos(phi/2.))/exprDivInt_5_1 
			- (Complex(0,2)*k*x*x)/exprDivInt_5_2 
			- (Complex(0,1)*om0*om0*tauG*tauG*rho0)/exprDivInt_5_2
			- (Complex(0,4)*y*y*rho0)/(exprDivInt_5_4*exprDivInt_5_4*exprDivInt_5_2)
			+ (om0*om0*tauG*tauG*y*cos(phi))/exprDivInt_5_2
			+ (4*y*y*y*cos(phi))/(exprDivInt_5_4*exprDivInt_5_4*exprDivInt_5_2)
			+ (om0*om0*tauG*tauG*z*sin(phi))/exprDivInt_5_2
			+ (4*y*y*z*sin(phi))/(exprDivInt_5_4*exprDivInt_5_4*exprDivInt_5_2)
			+ (Complex(0,2)*om0*y*y*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.))/exprDivInt_5_12
			+ (om0*y*rho0*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.))/exprDivInt_5_12
			+ (Complex(0,1)*om0*y*y*cos(phi)*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.))/exprDivInt_5_12
			+ (Complex(0,4)*om0*y*z*tan(phi/2.)*tan(phi/2.))/exprDivInt_5_12
			- (2*om0*z*rho0*tan(phi/2.)*tan(phi/2.))/exprDivInt_5_12
			- (Complex(0,2)*om0*z*z*sin(phi)*tan(phi/2.)*tan(phi/2.))/exprDivInt_5_12
			- (om0*exprPower*exprPower)/(exprDivInt_5_18*exprDivInt_5_19)
			)/4.;
					
			const Complex exprDivRat_1_1=cspeed*om0*tauG*tauG - Complex(0,1)*y*cos(phi)/cos(phi/2.)/cos(phi/2.)*tan(phi/2.) - Complex(0,2)*z*tan(phi/2.)*tan(phi/2.);
			const Complex result=(Complex(0,2)*Complex::cexp(exprE_1_1)*tauG*tan(phi/2.)*(cspeed*t - z + y*tan(phi/2.))*Complex::csqrt((om0*rho0)/exprDivInt_5_12))/Complex::csqrt(exprDivRat_1_1*exprDivRat_1_1*exprDivRat_1_1);

            return float_X( 2*result.get_real() );
        }
		
    };

    class fieldBackgroundJ
    {
    public:
        /* Add this additional field? */
        static const bool activated = false;

        /* We use this to calculate your SI input back to our unit system */
        const float3_64 unitField;
        HDINLINE fieldBackgroundJ( const float3_64 unitField ) : unitField(unitField)
        {}

        /** Specify your background field J(r,t) here
         *
         * \param cellIdx The total cell id counted from the start at t=0
         * \param currentStep The current time step */
        HDINLINE float3_X
        operator()( const DataSpace<simDim>& cellIdx,
                    const uint32_t currentStep ) const
        {
            /* example: periodicity of 20 microns (=2.0e-5 m) */
            const float_64 period_SI(20.0e-6);
            /* calculate cells -> SI -> m to microns*/
            const float_64 y_SI = cellIdx.y() * SI::CELL_HEIGHT_SI * 1.0e6;
            /* note: you can also transform the time step to seconds by
             *       multiplying with DELTA_T_SI */

            /* specify your J-Field in A/m^2 and convert to PIConGPU units */
            const float_X sinArg = precisionCast<float_X>( y_SI / period_SI * 2.0 * PI );
            return float3_X(0.0, math::cos( sinArg ) / unitField[1], 0.0);
        }
    };

} // namespace picongpu
